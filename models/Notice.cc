/**
 *
 *  Notice.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl
 *
 */

#include "Notice.h"
#include <drogon/utils/Utilities.h>
#include <string>

using namespace drogon;
using namespace drogon::orm;
using namespace drogon_model::techrater;

const std::string Notice::Cols::_id = "id";
const std::string Notice::Cols::_create_time = "create_time";
const std::string Notice::Cols::_en_us = "en_us";
const std::string Notice::Cols::_zh_cn = "zh_cn";
const std::string Notice::Cols::_zh_tw = "zh_tw";
const std::string Notice::Cols::_fr_fr = "fr_fr";
const std::string Notice::Cols::_es_es = "es_es";
const std::string Notice::Cols::_pt_pt = "pt_pt";
const std::string Notice::Cols::_id_id = "id_id";
const std::string Notice::Cols::_ja_jp = "ja_jp";
const std::string Notice::primaryKeyName = "id";
const bool Notice::hasPrimaryKey = true;
const std::string Notice::tableName = "notice";

const std::vector<typename Notice::MetaData> Notice::metaData_={
{"id","int64_t","bigint",8,1,1,1},
{"create_time","::trantor::Date","timestamp without time zone",0,0,0,0},
{"en_us","std::string","text",0,0,0,0},
{"zh_cn","std::string","text",0,0,0,0},
{"zh_tw","std::string","text",0,0,0,0},
{"fr_fr","std::string","text",0,0,0,0},
{"es_es","std::string","text",0,0,0,0},
{"pt_pt","std::string","text",0,0,0,0},
{"id_id","std::string","text",0,0,0,0},
{"ja_jp","std::string","text",0,0,0,0}
};
const std::string &Notice::getColumnName(size_t index) noexcept(false)
{
    assert(index < metaData_.size());
    return metaData_[index].colName_;
}
Notice::Notice(const Row &r, const ssize_t indexOffset) noexcept
{
    if(indexOffset < 0)
    {
        if(!r["id"].isNull())
        {
            id_=std::make_shared<int64_t>(r["id"].as<int64_t>());
        }
        if(!r["create_time"].isNull())
        {
            auto timeStr = r["create_time"].as<std::string>();
            struct tm stm;
            memset(&stm,0,sizeof(stm));
            auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
            time_t t = mktime(&stm);
            size_t decimalNum = 0;
            if(p)
            {
                if(*p=='.')
                {
                    std::string decimals(p+1,&timeStr[timeStr.length()]);
                    while(decimals.length()<6)
                    {
                        decimals += "0";
                    }
                    decimalNum = (size_t)atol(decimals.c_str());
                }
                createTime_=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
            }
        }
        if(!r["en_us"].isNull())
        {
            enUs_=std::make_shared<std::string>(r["en_us"].as<std::string>());
        }
        if(!r["zh_cn"].isNull())
        {
            zhCn_=std::make_shared<std::string>(r["zh_cn"].as<std::string>());
        }
        if(!r["zh_tw"].isNull())
        {
            zhTw_=std::make_shared<std::string>(r["zh_tw"].as<std::string>());
        }
        if(!r["fr_fr"].isNull())
        {
            frFr_=std::make_shared<std::string>(r["fr_fr"].as<std::string>());
        }
        if(!r["es_es"].isNull())
        {
            esEs_=std::make_shared<std::string>(r["es_es"].as<std::string>());
        }
        if(!r["pt_pt"].isNull())
        {
            ptPt_=std::make_shared<std::string>(r["pt_pt"].as<std::string>());
        }
        if(!r["id_id"].isNull())
        {
            idId_=std::make_shared<std::string>(r["id_id"].as<std::string>());
        }
        if(!r["ja_jp"].isNull())
        {
            jaJp_=std::make_shared<std::string>(r["ja_jp"].as<std::string>());
        }
    }
    else
    {
        size_t offset = (size_t)indexOffset;
        if(offset + 10 > r.size())
        {
            LOG_FATAL << "Invalid SQL result for this model";
            return;
        }
        size_t index;
        index = offset + 0;
        if(!r[index].isNull())
        {
            id_=std::make_shared<int64_t>(r[index].as<int64_t>());
        }
        index = offset + 1;
        if(!r[index].isNull())
        {
            auto timeStr = r[index].as<std::string>();
            struct tm stm;
            memset(&stm,0,sizeof(stm));
            auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
            time_t t = mktime(&stm);
            size_t decimalNum = 0;
            if(p)
            {
                if(*p=='.')
                {
                    std::string decimals(p+1,&timeStr[timeStr.length()]);
                    while(decimals.length()<6)
                    {
                        decimals += "0";
                    }
                    decimalNum = (size_t)atol(decimals.c_str());
                }
                createTime_=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
            }
        }
        index = offset + 2;
        if(!r[index].isNull())
        {
            enUs_=std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 3;
        if(!r[index].isNull())
        {
            zhCn_=std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 4;
        if(!r[index].isNull())
        {
            zhTw_=std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 5;
        if(!r[index].isNull())
        {
            frFr_=std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 6;
        if(!r[index].isNull())
        {
            esEs_=std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 7;
        if(!r[index].isNull())
        {
            ptPt_=std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 8;
        if(!r[index].isNull())
        {
            idId_=std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 9;
        if(!r[index].isNull())
        {
            jaJp_=std::make_shared<std::string>(r[index].as<std::string>());
        }
    }

}

Notice::Notice(const Json::Value &pJson, const std::vector<std::string> &pMasqueradingVector) noexcept(false)
{
    if(pMasqueradingVector.size() != 10)
    {
        LOG_ERROR << "Bad masquerading vector";
        return;
    }
    if(!pMasqueradingVector[0].empty() && pJson.isMember(pMasqueradingVector[0]))
    {
        dirtyFlag_[0] = true;
        if(!pJson[pMasqueradingVector[0]].isNull())
        {
            id_=std::make_shared<int64_t>((int64_t)pJson[pMasqueradingVector[0]].asInt64());
        }
    }
    if(!pMasqueradingVector[1].empty() && pJson.isMember(pMasqueradingVector[1]))
    {
        dirtyFlag_[1] = true;
        if(!pJson[pMasqueradingVector[1]].isNull())
        {
            auto timeStr = pJson[pMasqueradingVector[1]].asString();
            struct tm stm;
            memset(&stm,0,sizeof(stm));
            auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
            time_t t = mktime(&stm);
            size_t decimalNum = 0;
            if(p)
            {
                if(*p=='.')
                {
                    std::string decimals(p+1,&timeStr[timeStr.length()]);
                    while(decimals.length()<6)
                    {
                        decimals += "0";
                    }
                    decimalNum = (size_t)atol(decimals.c_str());
                }
                createTime_=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
            }
        }
    }
    if(!pMasqueradingVector[2].empty() && pJson.isMember(pMasqueradingVector[2]))
    {
        dirtyFlag_[2] = true;
        if(!pJson[pMasqueradingVector[2]].isNull())
        {
            enUs_=std::make_shared<std::string>(pJson[pMasqueradingVector[2]].asString());
        }
    }
    if(!pMasqueradingVector[3].empty() && pJson.isMember(pMasqueradingVector[3]))
    {
        dirtyFlag_[3] = true;
        if(!pJson[pMasqueradingVector[3]].isNull())
        {
            zhCn_=std::make_shared<std::string>(pJson[pMasqueradingVector[3]].asString());
        }
    }
    if(!pMasqueradingVector[4].empty() && pJson.isMember(pMasqueradingVector[4]))
    {
        dirtyFlag_[4] = true;
        if(!pJson[pMasqueradingVector[4]].isNull())
        {
            zhTw_=std::make_shared<std::string>(pJson[pMasqueradingVector[4]].asString());
        }
    }
    if(!pMasqueradingVector[5].empty() && pJson.isMember(pMasqueradingVector[5]))
    {
        dirtyFlag_[5] = true;
        if(!pJson[pMasqueradingVector[5]].isNull())
        {
            frFr_=std::make_shared<std::string>(pJson[pMasqueradingVector[5]].asString());
        }
    }
    if(!pMasqueradingVector[6].empty() && pJson.isMember(pMasqueradingVector[6]))
    {
        dirtyFlag_[6] = true;
        if(!pJson[pMasqueradingVector[6]].isNull())
        {
            esEs_=std::make_shared<std::string>(pJson[pMasqueradingVector[6]].asString());
        }
    }
    if(!pMasqueradingVector[7].empty() && pJson.isMember(pMasqueradingVector[7]))
    {
        dirtyFlag_[7] = true;
        if(!pJson[pMasqueradingVector[7]].isNull())
        {
            ptPt_=std::make_shared<std::string>(pJson[pMasqueradingVector[7]].asString());
        }
    }
    if(!pMasqueradingVector[8].empty() && pJson.isMember(pMasqueradingVector[8]))
    {
        dirtyFlag_[8] = true;
        if(!pJson[pMasqueradingVector[8]].isNull())
        {
            idId_=std::make_shared<std::string>(pJson[pMasqueradingVector[8]].asString());
        }
    }
    if(!pMasqueradingVector[9].empty() && pJson.isMember(pMasqueradingVector[9]))
    {
        dirtyFlag_[9] = true;
        if(!pJson[pMasqueradingVector[9]].isNull())
        {
            jaJp_=std::make_shared<std::string>(pJson[pMasqueradingVector[9]].asString());
        }
    }
}

Notice::Notice(const Json::Value &pJson) noexcept(false)
{
    if(pJson.isMember("id"))
    {
        dirtyFlag_[0]=true;
        if(!pJson["id"].isNull())
        {
            id_=std::make_shared<int64_t>((int64_t)pJson["id"].asInt64());
        }
    }
    if(pJson.isMember("create_time"))
    {
        dirtyFlag_[1]=true;
        if(!pJson["create_time"].isNull())
        {
            auto timeStr = pJson["create_time"].asString();
            struct tm stm;
            memset(&stm,0,sizeof(stm));
            auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
            time_t t = mktime(&stm);
            size_t decimalNum = 0;
            if(p)
            {
                if(*p=='.')
                {
                    std::string decimals(p+1,&timeStr[timeStr.length()]);
                    while(decimals.length()<6)
                    {
                        decimals += "0";
                    }
                    decimalNum = (size_t)atol(decimals.c_str());
                }
                createTime_=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
            }
        }
    }
    if(pJson.isMember("en_us"))
    {
        dirtyFlag_[2]=true;
        if(!pJson["en_us"].isNull())
        {
            enUs_=std::make_shared<std::string>(pJson["en_us"].asString());
        }
    }
    if(pJson.isMember("zh_cn"))
    {
        dirtyFlag_[3]=true;
        if(!pJson["zh_cn"].isNull())
        {
            zhCn_=std::make_shared<std::string>(pJson["zh_cn"].asString());
        }
    }
    if(pJson.isMember("zh_tw"))
    {
        dirtyFlag_[4]=true;
        if(!pJson["zh_tw"].isNull())
        {
            zhTw_=std::make_shared<std::string>(pJson["zh_tw"].asString());
        }
    }
    if(pJson.isMember("fr_fr"))
    {
        dirtyFlag_[5]=true;
        if(!pJson["fr_fr"].isNull())
        {
            frFr_=std::make_shared<std::string>(pJson["fr_fr"].asString());
        }
    }
    if(pJson.isMember("es_es"))
    {
        dirtyFlag_[6]=true;
        if(!pJson["es_es"].isNull())
        {
            esEs_=std::make_shared<std::string>(pJson["es_es"].asString());
        }
    }
    if(pJson.isMember("pt_pt"))
    {
        dirtyFlag_[7]=true;
        if(!pJson["pt_pt"].isNull())
        {
            ptPt_=std::make_shared<std::string>(pJson["pt_pt"].asString());
        }
    }
    if(pJson.isMember("id_id"))
    {
        dirtyFlag_[8]=true;
        if(!pJson["id_id"].isNull())
        {
            idId_=std::make_shared<std::string>(pJson["id_id"].asString());
        }
    }
    if(pJson.isMember("ja_jp"))
    {
        dirtyFlag_[9]=true;
        if(!pJson["ja_jp"].isNull())
        {
            jaJp_=std::make_shared<std::string>(pJson["ja_jp"].asString());
        }
    }
}

void Notice::updateByMasqueradedJson(const Json::Value &pJson,
                                            const std::vector<std::string> &pMasqueradingVector) noexcept(false)
{
    if(pMasqueradingVector.size() != 10)
    {
        LOG_ERROR << "Bad masquerading vector";
        return;
    }
    if(!pMasqueradingVector[0].empty() && pJson.isMember(pMasqueradingVector[0]))
    {
        if(!pJson[pMasqueradingVector[0]].isNull())
        {
            id_=std::make_shared<int64_t>((int64_t)pJson[pMasqueradingVector[0]].asInt64());
        }
    }
    if(!pMasqueradingVector[1].empty() && pJson.isMember(pMasqueradingVector[1]))
    {
        dirtyFlag_[1] = true;
        if(!pJson[pMasqueradingVector[1]].isNull())
        {
            auto timeStr = pJson[pMasqueradingVector[1]].asString();
            struct tm stm;
            memset(&stm,0,sizeof(stm));
            auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
            time_t t = mktime(&stm);
            size_t decimalNum = 0;
            if(p)
            {
                if(*p=='.')
                {
                    std::string decimals(p+1,&timeStr[timeStr.length()]);
                    while(decimals.length()<6)
                    {
                        decimals += "0";
                    }
                    decimalNum = (size_t)atol(decimals.c_str());
                }
                createTime_=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
            }
        }
    }
    if(!pMasqueradingVector[2].empty() && pJson.isMember(pMasqueradingVector[2]))
    {
        dirtyFlag_[2] = true;
        if(!pJson[pMasqueradingVector[2]].isNull())
        {
            enUs_=std::make_shared<std::string>(pJson[pMasqueradingVector[2]].asString());
        }
    }
    if(!pMasqueradingVector[3].empty() && pJson.isMember(pMasqueradingVector[3]))
    {
        dirtyFlag_[3] = true;
        if(!pJson[pMasqueradingVector[3]].isNull())
        {
            zhCn_=std::make_shared<std::string>(pJson[pMasqueradingVector[3]].asString());
        }
    }
    if(!pMasqueradingVector[4].empty() && pJson.isMember(pMasqueradingVector[4]))
    {
        dirtyFlag_[4] = true;
        if(!pJson[pMasqueradingVector[4]].isNull())
        {
            zhTw_=std::make_shared<std::string>(pJson[pMasqueradingVector[4]].asString());
        }
    }
    if(!pMasqueradingVector[5].empty() && pJson.isMember(pMasqueradingVector[5]))
    {
        dirtyFlag_[5] = true;
        if(!pJson[pMasqueradingVector[5]].isNull())
        {
            frFr_=std::make_shared<std::string>(pJson[pMasqueradingVector[5]].asString());
        }
    }
    if(!pMasqueradingVector[6].empty() && pJson.isMember(pMasqueradingVector[6]))
    {
        dirtyFlag_[6] = true;
        if(!pJson[pMasqueradingVector[6]].isNull())
        {
            esEs_=std::make_shared<std::string>(pJson[pMasqueradingVector[6]].asString());
        }
    }
    if(!pMasqueradingVector[7].empty() && pJson.isMember(pMasqueradingVector[7]))
    {
        dirtyFlag_[7] = true;
        if(!pJson[pMasqueradingVector[7]].isNull())
        {
            ptPt_=std::make_shared<std::string>(pJson[pMasqueradingVector[7]].asString());
        }
    }
    if(!pMasqueradingVector[8].empty() && pJson.isMember(pMasqueradingVector[8]))
    {
        dirtyFlag_[8] = true;
        if(!pJson[pMasqueradingVector[8]].isNull())
        {
            idId_=std::make_shared<std::string>(pJson[pMasqueradingVector[8]].asString());
        }
    }
    if(!pMasqueradingVector[9].empty() && pJson.isMember(pMasqueradingVector[9]))
    {
        dirtyFlag_[9] = true;
        if(!pJson[pMasqueradingVector[9]].isNull())
        {
            jaJp_=std::make_shared<std::string>(pJson[pMasqueradingVector[9]].asString());
        }
    }
}

void Notice::updateByJson(const Json::Value &pJson) noexcept(false)
{
    if(pJson.isMember("id"))
    {
        if(!pJson["id"].isNull())
        {
            id_=std::make_shared<int64_t>((int64_t)pJson["id"].asInt64());
        }
    }
    if(pJson.isMember("create_time"))
    {
        dirtyFlag_[1] = true;
        if(!pJson["create_time"].isNull())
        {
            auto timeStr = pJson["create_time"].asString();
            struct tm stm;
            memset(&stm,0,sizeof(stm));
            auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
            time_t t = mktime(&stm);
            size_t decimalNum = 0;
            if(p)
            {
                if(*p=='.')
                {
                    std::string decimals(p+1,&timeStr[timeStr.length()]);
                    while(decimals.length()<6)
                    {
                        decimals += "0";
                    }
                    decimalNum = (size_t)atol(decimals.c_str());
                }
                createTime_=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
            }
        }
    }
    if(pJson.isMember("en_us"))
    {
        dirtyFlag_[2] = true;
        if(!pJson["en_us"].isNull())
        {
            enUs_=std::make_shared<std::string>(pJson["en_us"].asString());
        }
    }
    if(pJson.isMember("zh_cn"))
    {
        dirtyFlag_[3] = true;
        if(!pJson["zh_cn"].isNull())
        {
            zhCn_=std::make_shared<std::string>(pJson["zh_cn"].asString());
        }
    }
    if(pJson.isMember("zh_tw"))
    {
        dirtyFlag_[4] = true;
        if(!pJson["zh_tw"].isNull())
        {
            zhTw_=std::make_shared<std::string>(pJson["zh_tw"].asString());
        }
    }
    if(pJson.isMember("fr_fr"))
    {
        dirtyFlag_[5] = true;
        if(!pJson["fr_fr"].isNull())
        {
            frFr_=std::make_shared<std::string>(pJson["fr_fr"].asString());
        }
    }
    if(pJson.isMember("es_es"))
    {
        dirtyFlag_[6] = true;
        if(!pJson["es_es"].isNull())
        {
            esEs_=std::make_shared<std::string>(pJson["es_es"].asString());
        }
    }
    if(pJson.isMember("pt_pt"))
    {
        dirtyFlag_[7] = true;
        if(!pJson["pt_pt"].isNull())
        {
            ptPt_=std::make_shared<std::string>(pJson["pt_pt"].asString());
        }
    }
    if(pJson.isMember("id_id"))
    {
        dirtyFlag_[8] = true;
        if(!pJson["id_id"].isNull())
        {
            idId_=std::make_shared<std::string>(pJson["id_id"].asString());
        }
    }
    if(pJson.isMember("ja_jp"))
    {
        dirtyFlag_[9] = true;
        if(!pJson["ja_jp"].isNull())
        {
            jaJp_=std::make_shared<std::string>(pJson["ja_jp"].asString());
        }
    }
}

const int64_t &Notice::getValueOfId() const noexcept
{
    const static int64_t defaultValue = int64_t();
    if(id_)
        return *id_;
    return defaultValue;
}
const std::shared_ptr<int64_t> &Notice::getId() const noexcept
{
    return id_;
}
void Notice::setId(const int64_t &pId) noexcept
{
    id_ = std::make_shared<int64_t>(pId);
    dirtyFlag_[0] = true;
}
const typename Notice::PrimaryKeyType & Notice::getPrimaryKey() const
{
    assert(id_);
    return *id_;
}

const ::trantor::Date &Notice::getValueOfCreateTime() const noexcept
{
    const static ::trantor::Date defaultValue = ::trantor::Date();
    if(createTime_)
        return *createTime_;
    return defaultValue;
}
const std::shared_ptr<::trantor::Date> &Notice::getCreateTime() const noexcept
{
    return createTime_;
}
void Notice::setCreateTime(const ::trantor::Date &pCreateTime) noexcept
{
    createTime_ = std::make_shared<::trantor::Date>(pCreateTime);
    dirtyFlag_[1] = true;
}
void Notice::setCreateTimeToNull() noexcept
{
    createTime_.reset();
    dirtyFlag_[1] = true;
}

const std::string &Notice::getValueOfEnUs() const noexcept
{
    const static std::string defaultValue = std::string();
    if(enUs_)
        return *enUs_;
    return defaultValue;
}
const std::shared_ptr<std::string> &Notice::getEnUs() const noexcept
{
    return enUs_;
}
void Notice::setEnUs(const std::string &pEnUs) noexcept
{
    enUs_ = std::make_shared<std::string>(pEnUs);
    dirtyFlag_[2] = true;
}
void Notice::setEnUs(std::string &&pEnUs) noexcept
{
    enUs_ = std::make_shared<std::string>(std::move(pEnUs));
    dirtyFlag_[2] = true;
}
void Notice::setEnUsToNull() noexcept
{
    enUs_.reset();
    dirtyFlag_[2] = true;
}

const std::string &Notice::getValueOfZhCn() const noexcept
{
    const static std::string defaultValue = std::string();
    if(zhCn_)
        return *zhCn_;
    return defaultValue;
}
const std::shared_ptr<std::string> &Notice::getZhCn() const noexcept
{
    return zhCn_;
}
void Notice::setZhCn(const std::string &pZhCn) noexcept
{
    zhCn_ = std::make_shared<std::string>(pZhCn);
    dirtyFlag_[3] = true;
}
void Notice::setZhCn(std::string &&pZhCn) noexcept
{
    zhCn_ = std::make_shared<std::string>(std::move(pZhCn));
    dirtyFlag_[3] = true;
}
void Notice::setZhCnToNull() noexcept
{
    zhCn_.reset();
    dirtyFlag_[3] = true;
}

const std::string &Notice::getValueOfZhTw() const noexcept
{
    const static std::string defaultValue = std::string();
    if(zhTw_)
        return *zhTw_;
    return defaultValue;
}
const std::shared_ptr<std::string> &Notice::getZhTw() const noexcept
{
    return zhTw_;
}
void Notice::setZhTw(const std::string &pZhTw) noexcept
{
    zhTw_ = std::make_shared<std::string>(pZhTw);
    dirtyFlag_[4] = true;
}
void Notice::setZhTw(std::string &&pZhTw) noexcept
{
    zhTw_ = std::make_shared<std::string>(std::move(pZhTw));
    dirtyFlag_[4] = true;
}
void Notice::setZhTwToNull() noexcept
{
    zhTw_.reset();
    dirtyFlag_[4] = true;
}

const std::string &Notice::getValueOfFrFr() const noexcept
{
    const static std::string defaultValue = std::string();
    if(frFr_)
        return *frFr_;
    return defaultValue;
}
const std::shared_ptr<std::string> &Notice::getFrFr() const noexcept
{
    return frFr_;
}
void Notice::setFrFr(const std::string &pFrFr) noexcept
{
    frFr_ = std::make_shared<std::string>(pFrFr);
    dirtyFlag_[5] = true;
}
void Notice::setFrFr(std::string &&pFrFr) noexcept
{
    frFr_ = std::make_shared<std::string>(std::move(pFrFr));
    dirtyFlag_[5] = true;
}
void Notice::setFrFrToNull() noexcept
{
    frFr_.reset();
    dirtyFlag_[5] = true;
}

const std::string &Notice::getValueOfEsEs() const noexcept
{
    const static std::string defaultValue = std::string();
    if(esEs_)
        return *esEs_;
    return defaultValue;
}
const std::shared_ptr<std::string> &Notice::getEsEs() const noexcept
{
    return esEs_;
}
void Notice::setEsEs(const std::string &pEsEs) noexcept
{
    esEs_ = std::make_shared<std::string>(pEsEs);
    dirtyFlag_[6] = true;
}
void Notice::setEsEs(std::string &&pEsEs) noexcept
{
    esEs_ = std::make_shared<std::string>(std::move(pEsEs));
    dirtyFlag_[6] = true;
}
void Notice::setEsEsToNull() noexcept
{
    esEs_.reset();
    dirtyFlag_[6] = true;
}

const std::string &Notice::getValueOfPtPt() const noexcept
{
    const static std::string defaultValue = std::string();
    if(ptPt_)
        return *ptPt_;
    return defaultValue;
}
const std::shared_ptr<std::string> &Notice::getPtPt() const noexcept
{
    return ptPt_;
}
void Notice::setPtPt(const std::string &pPtPt) noexcept
{
    ptPt_ = std::make_shared<std::string>(pPtPt);
    dirtyFlag_[7] = true;
}
void Notice::setPtPt(std::string &&pPtPt) noexcept
{
    ptPt_ = std::make_shared<std::string>(std::move(pPtPt));
    dirtyFlag_[7] = true;
}
void Notice::setPtPtToNull() noexcept
{
    ptPt_.reset();
    dirtyFlag_[7] = true;
}

const std::string &Notice::getValueOfIdId() const noexcept
{
    const static std::string defaultValue = std::string();
    if(idId_)
        return *idId_;
    return defaultValue;
}
const std::shared_ptr<std::string> &Notice::getIdId() const noexcept
{
    return idId_;
}
void Notice::setIdId(const std::string &pIdId) noexcept
{
    idId_ = std::make_shared<std::string>(pIdId);
    dirtyFlag_[8] = true;
}
void Notice::setIdId(std::string &&pIdId) noexcept
{
    idId_ = std::make_shared<std::string>(std::move(pIdId));
    dirtyFlag_[8] = true;
}
void Notice::setIdIdToNull() noexcept
{
    idId_.reset();
    dirtyFlag_[8] = true;
}

const std::string &Notice::getValueOfJaJp() const noexcept
{
    const static std::string defaultValue = std::string();
    if(jaJp_)
        return *jaJp_;
    return defaultValue;
}
const std::shared_ptr<std::string> &Notice::getJaJp() const noexcept
{
    return jaJp_;
}
void Notice::setJaJp(const std::string &pJaJp) noexcept
{
    jaJp_ = std::make_shared<std::string>(pJaJp);
    dirtyFlag_[9] = true;
}
void Notice::setJaJp(std::string &&pJaJp) noexcept
{
    jaJp_ = std::make_shared<std::string>(std::move(pJaJp));
    dirtyFlag_[9] = true;
}
void Notice::setJaJpToNull() noexcept
{
    jaJp_.reset();
    dirtyFlag_[9] = true;
}

void Notice::updateId(const uint64_t id)
{
}

const std::vector<std::string> &Notice::insertColumns() noexcept
{
    static const std::vector<std::string> inCols={
        "create_time",
        "en_us",
        "zh_cn",
        "zh_tw",
        "fr_fr",
        "es_es",
        "pt_pt",
        "id_id",
        "ja_jp"
    };
    return inCols;
}

void Notice::outputArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(dirtyFlag_[1])
    {
        if(getCreateTime())
        {
            binder << getValueOfCreateTime();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[2])
    {
        if(getEnUs())
        {
            binder << getValueOfEnUs();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[3])
    {
        if(getZhCn())
        {
            binder << getValueOfZhCn();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[4])
    {
        if(getZhTw())
        {
            binder << getValueOfZhTw();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[5])
    {
        if(getFrFr())
        {
            binder << getValueOfFrFr();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[6])
    {
        if(getEsEs())
        {
            binder << getValueOfEsEs();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[7])
    {
        if(getPtPt())
        {
            binder << getValueOfPtPt();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[8])
    {
        if(getIdId())
        {
            binder << getValueOfIdId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[9])
    {
        if(getJaJp())
        {
            binder << getValueOfJaJp();
        }
        else
        {
            binder << nullptr;
        }
    }
}

const std::vector<std::string> Notice::updateColumns() const
{
    std::vector<std::string> ret;
    if(dirtyFlag_[1])
    {
        ret.push_back(getColumnName(1));
    }
    if(dirtyFlag_[2])
    {
        ret.push_back(getColumnName(2));
    }
    if(dirtyFlag_[3])
    {
        ret.push_back(getColumnName(3));
    }
    if(dirtyFlag_[4])
    {
        ret.push_back(getColumnName(4));
    }
    if(dirtyFlag_[5])
    {
        ret.push_back(getColumnName(5));
    }
    if(dirtyFlag_[6])
    {
        ret.push_back(getColumnName(6));
    }
    if(dirtyFlag_[7])
    {
        ret.push_back(getColumnName(7));
    }
    if(dirtyFlag_[8])
    {
        ret.push_back(getColumnName(8));
    }
    if(dirtyFlag_[9])
    {
        ret.push_back(getColumnName(9));
    }
    return ret;
}

void Notice::updateArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(dirtyFlag_[1])
    {
        if(getCreateTime())
        {
            binder << getValueOfCreateTime();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[2])
    {
        if(getEnUs())
        {
            binder << getValueOfEnUs();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[3])
    {
        if(getZhCn())
        {
            binder << getValueOfZhCn();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[4])
    {
        if(getZhTw())
        {
            binder << getValueOfZhTw();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[5])
    {
        if(getFrFr())
        {
            binder << getValueOfFrFr();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[6])
    {
        if(getEsEs())
        {
            binder << getValueOfEsEs();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[7])
    {
        if(getPtPt())
        {
            binder << getValueOfPtPt();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[8])
    {
        if(getIdId())
        {
            binder << getValueOfIdId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(dirtyFlag_[9])
    {
        if(getJaJp())
        {
            binder << getValueOfJaJp();
        }
        else
        {
            binder << nullptr;
        }
    }
}
Json::Value Notice::toJson() const
{
    Json::Value ret;
    if(getId())
    {
        ret["id"]=(Json::Int64)getValueOfId();
    }
    else
    {
        ret["id"]=Json::Value();
    }
    if(getCreateTime())
    {
        ret["create_time"]=getCreateTime()->toDbStringLocal();
    }
    else
    {
        ret["create_time"]=Json::Value();
    }
    if(getEnUs())
    {
        ret["en_us"]=getValueOfEnUs();
    }
    else
    {
        ret["en_us"]=Json::Value();
    }
    if(getZhCn())
    {
        ret["zh_cn"]=getValueOfZhCn();
    }
    else
    {
        ret["zh_cn"]=Json::Value();
    }
    if(getZhTw())
    {
        ret["zh_tw"]=getValueOfZhTw();
    }
    else
    {
        ret["zh_tw"]=Json::Value();
    }
    if(getFrFr())
    {
        ret["fr_fr"]=getValueOfFrFr();
    }
    else
    {
        ret["fr_fr"]=Json::Value();
    }
    if(getEsEs())
    {
        ret["es_es"]=getValueOfEsEs();
    }
    else
    {
        ret["es_es"]=Json::Value();
    }
    if(getPtPt())
    {
        ret["pt_pt"]=getValueOfPtPt();
    }
    else
    {
        ret["pt_pt"]=Json::Value();
    }
    if(getIdId())
    {
        ret["id_id"]=getValueOfIdId();
    }
    else
    {
        ret["id_id"]=Json::Value();
    }
    if(getJaJp())
    {
        ret["ja_jp"]=getValueOfJaJp();
    }
    else
    {
        ret["ja_jp"]=Json::Value();
    }
    return ret;
}

Json::Value Notice::toMasqueradedJson(
    const std::vector<std::string> &pMasqueradingVector) const
{
    Json::Value ret;
    if(pMasqueradingVector.size() == 10)
    {
        if(!pMasqueradingVector[0].empty())
        {
            if(getId())
            {
                ret[pMasqueradingVector[0]]=(Json::Int64)getValueOfId();
            }
            else
            {
                ret[pMasqueradingVector[0]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[1].empty())
        {
            if(getCreateTime())
            {
                ret[pMasqueradingVector[1]]=getCreateTime()->toDbStringLocal();
            }
            else
            {
                ret[pMasqueradingVector[1]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[2].empty())
        {
            if(getEnUs())
            {
                ret[pMasqueradingVector[2]]=getValueOfEnUs();
            }
            else
            {
                ret[pMasqueradingVector[2]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[3].empty())
        {
            if(getZhCn())
            {
                ret[pMasqueradingVector[3]]=getValueOfZhCn();
            }
            else
            {
                ret[pMasqueradingVector[3]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[4].empty())
        {
            if(getZhTw())
            {
                ret[pMasqueradingVector[4]]=getValueOfZhTw();
            }
            else
            {
                ret[pMasqueradingVector[4]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[5].empty())
        {
            if(getFrFr())
            {
                ret[pMasqueradingVector[5]]=getValueOfFrFr();
            }
            else
            {
                ret[pMasqueradingVector[5]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[6].empty())
        {
            if(getEsEs())
            {
                ret[pMasqueradingVector[6]]=getValueOfEsEs();
            }
            else
            {
                ret[pMasqueradingVector[6]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[7].empty())
        {
            if(getPtPt())
            {
                ret[pMasqueradingVector[7]]=getValueOfPtPt();
            }
            else
            {
                ret[pMasqueradingVector[7]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[8].empty())
        {
            if(getIdId())
            {
                ret[pMasqueradingVector[8]]=getValueOfIdId();
            }
            else
            {
                ret[pMasqueradingVector[8]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[9].empty())
        {
            if(getJaJp())
            {
                ret[pMasqueradingVector[9]]=getValueOfJaJp();
            }
            else
            {
                ret[pMasqueradingVector[9]]=Json::Value();
            }
        }
        return ret;
    }
    LOG_ERROR << "Masquerade failed";
    if(getId())
    {
        ret["id"]=(Json::Int64)getValueOfId();
    }
    else
    {
        ret["id"]=Json::Value();
    }
    if(getCreateTime())
    {
        ret["create_time"]=getCreateTime()->toDbStringLocal();
    }
    else
    {
        ret["create_time"]=Json::Value();
    }
    if(getEnUs())
    {
        ret["en_us"]=getValueOfEnUs();
    }
    else
    {
        ret["en_us"]=Json::Value();
    }
    if(getZhCn())
    {
        ret["zh_cn"]=getValueOfZhCn();
    }
    else
    {
        ret["zh_cn"]=Json::Value();
    }
    if(getZhTw())
    {
        ret["zh_tw"]=getValueOfZhTw();
    }
    else
    {
        ret["zh_tw"]=Json::Value();
    }
    if(getFrFr())
    {
        ret["fr_fr"]=getValueOfFrFr();
    }
    else
    {
        ret["fr_fr"]=Json::Value();
    }
    if(getEsEs())
    {
        ret["es_es"]=getValueOfEsEs();
    }
    else
    {
        ret["es_es"]=Json::Value();
    }
    if(getPtPt())
    {
        ret["pt_pt"]=getValueOfPtPt();
    }
    else
    {
        ret["pt_pt"]=Json::Value();
    }
    if(getIdId())
    {
        ret["id_id"]=getValueOfIdId();
    }
    else
    {
        ret["id_id"]=Json::Value();
    }
    if(getJaJp())
    {
        ret["ja_jp"]=getValueOfJaJp();
    }
    else
    {
        ret["ja_jp"]=Json::Value();
    }
    return ret;
}

bool Notice::validateJsonForCreation(const Json::Value &pJson, std::string &err)
{
    if(pJson.isMember("id"))
    {
        if(!validJsonOfField(0, "id", pJson["id"], err, true))
            return false;
    }
    if(pJson.isMember("create_time"))
    {
        if(!validJsonOfField(1, "create_time", pJson["create_time"], err, true))
            return false;
    }
    if(pJson.isMember("en_us"))
    {
        if(!validJsonOfField(2, "en_us", pJson["en_us"], err, true))
            return false;
    }
    if(pJson.isMember("zh_cn"))
    {
        if(!validJsonOfField(3, "zh_cn", pJson["zh_cn"], err, true))
            return false;
    }
    if(pJson.isMember("zh_tw"))
    {
        if(!validJsonOfField(4, "zh_tw", pJson["zh_tw"], err, true))
            return false;
    }
    if(pJson.isMember("fr_fr"))
    {
        if(!validJsonOfField(5, "fr_fr", pJson["fr_fr"], err, true))
            return false;
    }
    if(pJson.isMember("es_es"))
    {
        if(!validJsonOfField(6, "es_es", pJson["es_es"], err, true))
            return false;
    }
    if(pJson.isMember("pt_pt"))
    {
        if(!validJsonOfField(7, "pt_pt", pJson["pt_pt"], err, true))
            return false;
    }
    if(pJson.isMember("id_id"))
    {
        if(!validJsonOfField(8, "id_id", pJson["id_id"], err, true))
            return false;
    }
    if(pJson.isMember("ja_jp"))
    {
        if(!validJsonOfField(9, "ja_jp", pJson["ja_jp"], err, true))
            return false;
    }
    return true;
}
bool Notice::validateMasqueradedJsonForCreation(const Json::Value &pJson,
                                                const std::vector<std::string> &pMasqueradingVector,
                                                std::string &err)
{
    if(pMasqueradingVector.size() != 10)
    {
        err = "Bad masquerading vector";
        return false;
    }
    try {
      if(!pMasqueradingVector[0].empty())
      {
          if(pJson.isMember(pMasqueradingVector[0]))
          {
              if(!validJsonOfField(0, pMasqueradingVector[0], pJson[pMasqueradingVector[0]], err, true))
                  return false;
          }
      }
      if(!pMasqueradingVector[1].empty())
      {
          if(pJson.isMember(pMasqueradingVector[1]))
          {
              if(!validJsonOfField(1, pMasqueradingVector[1], pJson[pMasqueradingVector[1]], err, true))
                  return false;
          }
      }
      if(!pMasqueradingVector[2].empty())
      {
          if(pJson.isMember(pMasqueradingVector[2]))
          {
              if(!validJsonOfField(2, pMasqueradingVector[2], pJson[pMasqueradingVector[2]], err, true))
                  return false;
          }
      }
      if(!pMasqueradingVector[3].empty())
      {
          if(pJson.isMember(pMasqueradingVector[3]))
          {
              if(!validJsonOfField(3, pMasqueradingVector[3], pJson[pMasqueradingVector[3]], err, true))
                  return false;
          }
      }
      if(!pMasqueradingVector[4].empty())
      {
          if(pJson.isMember(pMasqueradingVector[4]))
          {
              if(!validJsonOfField(4, pMasqueradingVector[4], pJson[pMasqueradingVector[4]], err, true))
                  return false;
          }
      }
      if(!pMasqueradingVector[5].empty())
      {
          if(pJson.isMember(pMasqueradingVector[5]))
          {
              if(!validJsonOfField(5, pMasqueradingVector[5], pJson[pMasqueradingVector[5]], err, true))
                  return false;
          }
      }
      if(!pMasqueradingVector[6].empty())
      {
          if(pJson.isMember(pMasqueradingVector[6]))
          {
              if(!validJsonOfField(6, pMasqueradingVector[6], pJson[pMasqueradingVector[6]], err, true))
                  return false;
          }
      }
      if(!pMasqueradingVector[7].empty())
      {
          if(pJson.isMember(pMasqueradingVector[7]))
          {
              if(!validJsonOfField(7, pMasqueradingVector[7], pJson[pMasqueradingVector[7]], err, true))
                  return false;
          }
      }
      if(!pMasqueradingVector[8].empty())
      {
          if(pJson.isMember(pMasqueradingVector[8]))
          {
              if(!validJsonOfField(8, pMasqueradingVector[8], pJson[pMasqueradingVector[8]], err, true))
                  return false;
          }
      }
      if(!pMasqueradingVector[9].empty())
      {
          if(pJson.isMember(pMasqueradingVector[9]))
          {
              if(!validJsonOfField(9, pMasqueradingVector[9], pJson[pMasqueradingVector[9]], err, true))
                  return false;
          }
      }
    }
    catch(const Json::LogicError &e)
    {
      err = e.what();
      return false;
    }
    return true;
}
bool Notice::validateJsonForUpdate(const Json::Value &pJson, std::string &err)
{
    if(pJson.isMember("id"))
    {
        if(!validJsonOfField(0, "id", pJson["id"], err, false))
            return false;
    }
    else
    {
        err = "The value of primary key must be set in the json object for update";
        return false;
    }
    if(pJson.isMember("create_time"))
    {
        if(!validJsonOfField(1, "create_time", pJson["create_time"], err, false))
            return false;
    }
    if(pJson.isMember("en_us"))
    {
        if(!validJsonOfField(2, "en_us", pJson["en_us"], err, false))
            return false;
    }
    if(pJson.isMember("zh_cn"))
    {
        if(!validJsonOfField(3, "zh_cn", pJson["zh_cn"], err, false))
            return false;
    }
    if(pJson.isMember("zh_tw"))
    {
        if(!validJsonOfField(4, "zh_tw", pJson["zh_tw"], err, false))
            return false;
    }
    if(pJson.isMember("fr_fr"))
    {
        if(!validJsonOfField(5, "fr_fr", pJson["fr_fr"], err, false))
            return false;
    }
    if(pJson.isMember("es_es"))
    {
        if(!validJsonOfField(6, "es_es", pJson["es_es"], err, false))
            return false;
    }
    if(pJson.isMember("pt_pt"))
    {
        if(!validJsonOfField(7, "pt_pt", pJson["pt_pt"], err, false))
            return false;
    }
    if(pJson.isMember("id_id"))
    {
        if(!validJsonOfField(8, "id_id", pJson["id_id"], err, false))
            return false;
    }
    if(pJson.isMember("ja_jp"))
    {
        if(!validJsonOfField(9, "ja_jp", pJson["ja_jp"], err, false))
            return false;
    }
    return true;
}
bool Notice::validateMasqueradedJsonForUpdate(const Json::Value &pJson,
                                              const std::vector<std::string> &pMasqueradingVector,
                                              std::string &err)
{
    if(pMasqueradingVector.size() != 10)
    {
        err = "Bad masquerading vector";
        return false;
    }
    try {
      if(!pMasqueradingVector[0].empty() && pJson.isMember(pMasqueradingVector[0]))
      {
          if(!validJsonOfField(0, pMasqueradingVector[0], pJson[pMasqueradingVector[0]], err, false))
              return false;
      }
    else
    {
        err = "The value of primary key must be set in the json object for update";
        return false;
    }
      if(!pMasqueradingVector[1].empty() && pJson.isMember(pMasqueradingVector[1]))
      {
          if(!validJsonOfField(1, pMasqueradingVector[1], pJson[pMasqueradingVector[1]], err, false))
              return false;
      }
      if(!pMasqueradingVector[2].empty() && pJson.isMember(pMasqueradingVector[2]))
      {
          if(!validJsonOfField(2, pMasqueradingVector[2], pJson[pMasqueradingVector[2]], err, false))
              return false;
      }
      if(!pMasqueradingVector[3].empty() && pJson.isMember(pMasqueradingVector[3]))
      {
          if(!validJsonOfField(3, pMasqueradingVector[3], pJson[pMasqueradingVector[3]], err, false))
              return false;
      }
      if(!pMasqueradingVector[4].empty() && pJson.isMember(pMasqueradingVector[4]))
      {
          if(!validJsonOfField(4, pMasqueradingVector[4], pJson[pMasqueradingVector[4]], err, false))
              return false;
      }
      if(!pMasqueradingVector[5].empty() && pJson.isMember(pMasqueradingVector[5]))
      {
          if(!validJsonOfField(5, pMasqueradingVector[5], pJson[pMasqueradingVector[5]], err, false))
              return false;
      }
      if(!pMasqueradingVector[6].empty() && pJson.isMember(pMasqueradingVector[6]))
      {
          if(!validJsonOfField(6, pMasqueradingVector[6], pJson[pMasqueradingVector[6]], err, false))
              return false;
      }
      if(!pMasqueradingVector[7].empty() && pJson.isMember(pMasqueradingVector[7]))
      {
          if(!validJsonOfField(7, pMasqueradingVector[7], pJson[pMasqueradingVector[7]], err, false))
              return false;
      }
      if(!pMasqueradingVector[8].empty() && pJson.isMember(pMasqueradingVector[8]))
      {
          if(!validJsonOfField(8, pMasqueradingVector[8], pJson[pMasqueradingVector[8]], err, false))
              return false;
      }
      if(!pMasqueradingVector[9].empty() && pJson.isMember(pMasqueradingVector[9]))
      {
          if(!validJsonOfField(9, pMasqueradingVector[9], pJson[pMasqueradingVector[9]], err, false))
              return false;
      }
    }
    catch(const Json::LogicError &e)
    {
      err = e.what();
      return false;
    }
    return true;
}
bool Notice::validJsonOfField(size_t index,
                              const std::string &fieldName,
                              const Json::Value &pJson,
                              std::string &err,
                              bool isForCreation)
{
    switch(index)
    {
        case 0:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(isForCreation)
            {
                err="The automatic primary key cannot be set";
                return false;
            }
            if(!pJson.isInt64())
            {
                err="Type error in the "+fieldName+" field";
                return false;
            }
            break;
        case 1:
            if(pJson.isNull())
            {
                return true;
            }
            if(!pJson.isString())
            {
                err="Type error in the "+fieldName+" field";
                return false;
            }
            break;
        case 2:
            if(pJson.isNull())
            {
                return true;
            }
            if(!pJson.isString())
            {
                err="Type error in the "+fieldName+" field";
                return false;
            }
            break;
        case 3:
            if(pJson.isNull())
            {
                return true;
            }
            if(!pJson.isString())
            {
                err="Type error in the "+fieldName+" field";
                return false;
            }
            break;
        case 4:
            if(pJson.isNull())
            {
                return true;
            }
            if(!pJson.isString())
            {
                err="Type error in the "+fieldName+" field";
                return false;
            }
            break;
        case 5:
            if(pJson.isNull())
            {
                return true;
            }
            if(!pJson.isString())
            {
                err="Type error in the "+fieldName+" field";
                return false;
            }
            break;
        case 6:
            if(pJson.isNull())
            {
                return true;
            }
            if(!pJson.isString())
            {
                err="Type error in the "+fieldName+" field";
                return false;
            }
            break;
        case 7:
            if(pJson.isNull())
            {
                return true;
            }
            if(!pJson.isString())
            {
                err="Type error in the "+fieldName+" field";
                return false;
            }
            break;
        case 8:
            if(pJson.isNull())
            {
                return true;
            }
            if(!pJson.isString())
            {
                err="Type error in the "+fieldName+" field";
                return false;
            }
            break;
        case 9:
            if(pJson.isNull())
            {
                return true;
            }
            if(!pJson.isString())
            {
                err="Type error in the "+fieldName+" field";
                return false;
            }
            break;
        default:
            err="Internal error in the server";
            return false;
    }
    return true;
}
